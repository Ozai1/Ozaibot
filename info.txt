const mysql = require('mysql2');
const connection = mysql.createPool({
        host: 'localhost',
        user: 'root',
        database: 'ozaibot',
        waitForConnections: true,
        connectionLimit: 10,
        queueLimit: 0
    });


const mysql = require('mysql2')
const serversdb = mysql.createPool({
      host: 'localhost',
      user: 'root',
      database: 'ozaibotservers',
      waitForConnections: true,
      connectionLimit: 10,
      queueLimit: 0
});

 ozai-508847949413875712 cherry-753454519937007696 gary-855480412319383592 leon-816968930564243457
2147483648 max settimeout time 🇦 🇧 🇨 🇩 🇪 🇫 🇬 🇭 🇮 🇯 🇰 🇱 🇲 🇳 🇴 🇵 🇶 🇷 🇸 🇹 🇺 🇻 🇼 🇽 🇾 🇿 ✅☑️❎✖️❌
 ids are 17 or 18 long
** **
let muteRole = message.guild.roles.cache.find(role => role.name.toLowerCase() === "go away");
message.guild.channels.cache.forEach(async (channel, id) => {
await channel.updateOverwrite(muteRole, {
VIEW_CHANNEL: false })})

ADMINISTRATOR
CREATE_INSTANT_INVITE
KICK_MEMBERS
BAN_MEMBERS
MANAGE_CHANNELS
MANAGE_GUILD
ADD_REACTIONS
VIEW_AUDIT_LOG
VIEW_CHANNEL
READ_MESSAGES
SEND_MESSAGES
SEND_TTS_MESSAGES
MANAGE_MESSAGES
EMBED_LINKS
ATTACH_FILES
READ_MESSAGE_HISTORY
MENTION_EVERYONE
USE_EXTERNAL_EMOJIS
EXTERNAL_EMOJIS
CONNECT // Voice Channel
SPEAK
MUTE_MEMBERS
DEAFEN_MEMBERS
MOVE_MEMBERS
USE_VAD // Voice Auto Detection
CHANGE_NICKNAME
MANAGE_NICKNAMES
MANAGE_ROLES
MANAGE_ROLES_OR_PERMISSIONS
MANAGE_WEBHOOKS
MANAGE_EMOJIS

 { name: "Permissions", value: "uvbiurgb", inline: true},
           let author2 = message.author
          if (!user) return message.reply('You must ping a user.')
         let filter = m => m.author.id === message.author.id
         message.channel.send(`are you sure you want to blacklist ${user.username}? \`YES\` / \`NO\``).then(() => {
              message.channel.awaitMessages(filter, { max: 1, time: 30000, errors: ['time'], }).then(message => {
                  message = message.first();
                   if (message.content.toUpperCase() == 'YES' || message.content.toUpperCase() == 'Y') {
                         <code>
               } else if (message.content.toUpperCase() == 'NO' || message.content.toUpperCase() == 'N') {
                    >code>
              } else {
                     message.channel.send(`Cancelled: Invalid Response`);
                  }
             }).catch(collected => {
                    message.channel.send('Timed out');
					              });
         })


let query = "SELECT * FROM poo WHERE userid = ?";
let query = "INSERT INTO poo (username, userid) VALUES (?, ?)";
let query = "DELETE FROM poo WHERE userid = ?";
let query = "UPDATE poo SET username = ? WHERE userid = ?";
if (error) return console.log(error)

for (row of results) {
var username1 = row["username"];
}


DELETING FROM STRING START AND END
.slice(0, -1)
           ^ amount to remove from end (make sure to include the -
.slice (1)
        ^ amount to remove from start
for (i = 0; i <= 100; i = i + 1) { 
}


CONVERTING MESSAGE ID INTO A TIMESTAMP 
const DISCORD_EPOCH = 1420070400000
const convertSnowflakeToDate = (snowflake, epoch = DISCORD_EPOCH) => {
      //converts
	return console.log( new Date(snowflake / 4194304 + epoch))
}
const validateSnowflake = (snowflake, DISCORD_EPOCH) => {
      //checks if it is a valid id
	if (!Number.isInteger(+snowflake)) {
		console.log("That doesn't look like a snowflake. Snowflakes contain only numbers.")
            
	}
	if (snowflake < 4194304) {
		console.log("That doesn't look like a snowflake. Snowflakes are much larger numbers.")
	}
	const timestamp = convertSnowflakeToDate(snowflake, DISCORD_EPOCH)
      if (!timestamp) return console.log('timestamp couldnt be created?')
	if (isNaN(timestamp.getTime())) {
		console.log("That doesn't look like a snowflake. Snowflakes have fewer digits.")
	}
	return console.log(timestamp)
}

ME SUBSTRING SEARCH SHIT SO FAR 

            let possiblechannels = [];
                  message.guild.channels.cache.forEach(channel => {
                        if (channel.type === 'voice') {
                              if (channel.name.toLowerCase().includes(args[0].toLowerCase())) {
                                    possiblechannels.push(`#${possiblechannels.length} ${channel.name}`)
                              }
                        }
                  })
                  if (!possiblechannels[1]) {
                        let channel2 = message.guild.channels.cache.find(channel => channel.name === possiblechannels[0].slice(3));
                        if (!channel2 || channel2.type === 'text' || channel2.type === 'category' || channel2.type === 'dm') return message.author.send('Usage is `sm_drag <channel> <user|vc> <user> <user> etc`\nuser(s) are optional');
                        if (!args[1]) {
                              message.member.voice.setChannel(channel2).catch(err => { console.log(err) });
                        } else if (args[1].toLowerCase() === 'vc') {
                              message.member.voice.channel.members.forEach(member => {
                                    if (member.voice.channel) {
                                          member.voice.setChannel(channel2).catch(err => { console.log(err) })
                                    }
                              })
                              return
                        } else {
                              args.forEach(singlearg => {
                                    let member = message.guild.members.cache.get(singlearg.slice(3, -1)) || message.guild.members.cache.get(singlearg) || message.guild.members.cache.get(singlearg.slice(2, -1));
                                    if (member) {
                                          member.voice.setChannel(channel2).catch(err => { console.log(err) });
                                    }
                              })
                        }
                        return
                  } else if (!possiblechannels[0]) {
                        return message.author.send('Could not find a channel with that name or a channel that has that in its name.')
                  }
                  if (possiblechannels.length > 9) message.channel.send('To many possible channels from that name, use a more definitive string.')
                  const helpembed = new Discord.MessageEmbed()
                        .setTitle('Which of these channels did you mean? Please type out the corrosponding number.')
                        .setDescription(possiblechannels)
                        .setFooter('Hi Jan')
                        .setColor('BLUE')
                  let filter = m => m.author.id === message.author.id;
                  await message.channel.send({embeds: [helpembed]}).then(confmessage => {
                        message.channel.awaitMessages(filter, { max: 1, time: 30000, errors: ['time'], }).then(async message2 => {
                              message2 = message2.first();
                              message2.delete().catch(err => { })
                              confmessage.delete().catch(err => { })
                              if (isNaN(message2.content)) return message2.channel.send('Failed, you are supposed to pick one of the channels #-numbers.')
                              if (message2.content >= possiblechannels.length) return message2.channel.send('Failed, that number isnt on the list.')
                              let channel2 = message2.guild.channels.cache.find(channel => channel.name === possiblechannels[message2.content].slice(3));
                              if (!channel2 || channel2.type === 'text' || channel2.type === 'category' || channel2.type === 'dm') return message.author.send('Usage is `sm_drag <channel> <user|vc> <user> <user> etc`\nuser(s) are optional');
                              if (!args[1]) {
                                    message2.member.voice.setChannel(channel2).catch(err => { console.log(err) });
                              } else if (args[1].toLowerCase() === 'vc') {
                                    message2.member.voice.channel.members.forEach(member => {
                                          if (member.voice.channel) {
                                                member.voice.setChannel(channel2).catch(err => { console.log(err) })
                                          }
                                    })
                                    return
                              } else {
                                    args.forEach(singlearg => {
                                          let member = message2.guild.members.cache.get(singlearg.slice(3, -1)) || message.guild.members.cache.get(singlearg) || message.guild.members.cache.get(singlearg.slice(2, -1));
                                          if (member) {
                                                member.voice.setChannel(channel2).catch(err => { console.log(err) });
                                          }
                                    })
                              }
                              return
                        }).catch(collected => {
                              console.log(collected)
                              return message.channel.send('Timed out').catch(err => { console.log(err) })
                        });
                  });
            